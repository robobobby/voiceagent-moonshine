<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VoiceAgent</title>
<style>
  :root {
    --bg: #08080c;
    --surface: #111118;
    --surface2: #1a1a24;
    --border: #252535;
    --text: #e4e4ef;
    --text-dim: #6b6b80;
    --text-muted: #444458;
    --accent: #818cf8;
    --accent-dim: rgba(129, 140, 248, 0.15);
    --user: #a78bfa;
    --agent: #34d399;
    --agent-dim: rgba(52, 211, 153, 0.12);
    --error: #f87171;
    --recording: #ef4444;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, 'SF Pro Text', 'Inter', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  /* Header */
  .header {
    padding: 1.25rem 1.5rem;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    backdrop-filter: blur(12px);
    background: rgba(8, 8, 12, 0.8);
    position: sticky;
    top: 0;
    z-index: 10;
  }
  .header h1 {
    font-size: 0.95rem;
    font-weight: 600;
    letter-spacing: 0.08em;
  }
  .header h1 .dot { color: var(--agent); }
  .header .meta {
    font-size: 0.7rem;
    color: var(--text-dim);
    font-family: 'SF Mono', 'Fira Code', monospace;
  }
  .status-dot {
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    margin-right: 6px;
    vertical-align: middle;
  }
  .status-dot.connected { background: var(--agent); }
  .status-dot.disconnected { background: var(--error); }

  .clear-btn {
    background: none;
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-size: 0.7rem;
    padding: 4px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
  }
  .clear-btn:hover { border-color: var(--text-dim); color: var(--text); }

  /* Chat area */
  .chat {
    flex: 1;
    overflow-y: auto;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .message {
    max-width: 85%;
    padding: 0.75rem 1rem;
    border-radius: 12px;
    font-size: 0.9rem;
    line-height: 1.55;
    position: relative;
    animation: fadeIn 0.25s ease;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(6px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .message.user {
    align-self: flex-end;
    background: var(--accent-dim);
    border: 1px solid rgba(129, 140, 248, 0.2);
    color: var(--text);
  }
  .message.agent {
    align-self: flex-start;
    background: var(--agent-dim);
    border: 1px solid rgba(52, 211, 153, 0.15);
    color: var(--text);
  }
  .message .timing {
    font-size: 0.6rem;
    color: var(--text-muted);
    margin-top: 0.4rem;
    font-family: 'SF Mono', 'Fira Code', monospace;
  }
  .message.agent .speaking-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--agent);
    margin-left: 6px;
    animation: pulse 1s ease-in-out infinite;
    vertical-align: middle;
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .message.thinking {
    align-self: flex-start;
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-style: italic;
  }

  .empty-chat {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    gap: 0.75rem;
  }
  .empty-chat .icon { font-size: 2.5rem; opacity: 0.3; }
  .empty-chat .hint { font-size: 0.8rem; }

  /* Bottom bar */
  .bottom-bar {
    padding: 1rem 1.5rem 1.5rem;
    border-top: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.75rem;
    background: var(--surface);
  }

  .visualizer {
    width: 100%;
    max-width: 480px;
    height: 36px;
  }
  .visualizer canvas {
    width: 100%;
    height: 100%;
    border-radius: 6px;
  }

  .mic-row {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .mic-btn {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background: var(--surface2);
    border: 2px solid var(--border);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    position: relative;
  }
  .mic-btn:hover { border-color: var(--accent); }
  .mic-btn svg { width: 28px; height: 28px; fill: var(--text-dim); transition: fill 0.2s; }
  .mic-btn.recording {
    border-color: var(--recording);
    box-shadow: 0 0 24px rgba(239, 68, 68, 0.25);
    animation: pulse-btn 1.2s ease-in-out infinite;
  }
  .mic-btn.recording svg { fill: var(--recording); }
  @keyframes pulse-btn {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }

  .mic-hint {
    font-size: 0.65rem;
    color: var(--text-muted);
    font-family: 'SF Mono', 'Fira Code', monospace;
  }

  .tts-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.7rem;
    color: var(--text-dim);
    cursor: pointer;
    user-select: none;
  }
  .tts-toggle input { accent-color: var(--agent); }

  /* Mobile */
  @media (max-width: 600px) {
    .message { max-width: 92%; }
    .header { padding: 1rem; }
    .chat { padding: 1rem; }
  }
</style>
</head>
<body>

<div class="header">
  <div>
    <h1>VoiceAgent<span class="dot">.</span></h1>
    <div class="meta">
      <span class="status-dot disconnected" id="statusDot"></span>
      <span id="statusText">connecting...</span>
    </div>
  </div>
  <button class="clear-btn" id="clearBtn">clear chat</button>
</div>

<div class="chat" id="chat">
  <div class="empty-chat" id="emptyState">
    <div class="icon">üéôÔ∏è</div>
    <div class="hint">Hold the mic button or press Space to speak</div>
    <div class="hint" style="font-size:0.7rem; color: var(--text-muted)">Moonshine STT ‚Üí GPT-4o-mini ‚Üí OpenAI TTS</div>
  </div>
</div>

<div class="bottom-bar">
  <div class="visualizer">
    <canvas id="visualizer"></canvas>
  </div>
  <div class="mic-row">
    <label class="tts-toggle">
      <input type="checkbox" id="ttsToggle" checked>
      speak replies
    </label>
    <button class="mic-btn" id="micBtn" title="Hold to speak">
      <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5zm6 6c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
    </button>
    <div class="mic-hint" id="micHint">space / hold</div>
  </div>
</div>

<script>
const WS_URL = location.protocol === 'https:' ? `wss://${location.hostname}:${location.port}/ws` : 'ws://localhost:8765';
const SAMPLE_RATE = 16000;

let ws = null;
let audioCtx = null;
let mediaStream = null;
let recording = false;
let audioChunks = [];
let analyser = null;
let animFrame = null;
let speaking = false;

// --- WebSocket ---
function connect() {
  ws = new WebSocket(WS_URL);
  ws.binaryType = 'arraybuffer';

  ws.onopen = () => {
    document.getElementById('statusDot').className = 'status-dot connected';
    document.getElementById('statusText').textContent = 'moonshine ¬∑ gpt-4o-mini';
  };
  ws.onclose = () => {
    document.getElementById('statusDot').className = 'status-dot disconnected';
    document.getElementById('statusText').textContent = 'reconnecting...';
    setTimeout(connect, 2000);
  };
  ws.binaryType = 'blob';
  ws.onmessage = (e) => {
    // Binary message = TTS audio
    if (e.data instanceof Blob) {
      if (ttsAudioPending && document.getElementById('ttsToggle').checked) {
        playTtsAudio(e.data);
      }
      ttsAudioPending = false;
      return;
    }
    const data = JSON.parse(e.data);
    if (data.type === 'tts_audio') {
      ttsAudioPending = true;
      return;
    }
    if (data.type === 'user_message') {
      removeThinking();
      addMessage('user', data.text, `${data.audio_seconds}s audio ¬∑ ${data.stt_ms}ms stt`);
      addThinking();
    } else if (data.type === 'agent_response') {
      removeThinking();
      addMessage('agent', data.text, `${data.llm_ms}ms llm ¬∑ ${data.total_ms}ms total`);
      // TTS audio arrives as a separate binary message from server
    } else if (data.type === 'error') {
      removeThinking();
      addMessage('agent', data.message, 'error');
    } else if (data.type === 'history_cleared') {
      document.getElementById('chat').innerHTML = '';
      showEmpty();
    }
  };
}

// --- Chat UI ---
function addMessage(role, text, timing) {
  hideEmpty();
  const chat = document.getElementById('chat');
  const msg = document.createElement('div');
  msg.className = `message ${role}`;
  msg.innerHTML = `
    <div>${escapeHtml(text)}</div>
    ${timing ? `<div class="timing">${timing}</div>` : ''}
  `;
  chat.appendChild(msg);
  chat.scrollTop = chat.scrollHeight;
}

function addThinking() {
  hideEmpty();
  const chat = document.getElementById('chat');
  const msg = document.createElement('div');
  msg.className = 'message thinking';
  msg.id = 'thinkingMsg';
  msg.innerHTML = 'thinking...';
  chat.appendChild(msg);
  chat.scrollTop = chat.scrollHeight;
}

function removeThinking() {
  const el = document.getElementById('thinkingMsg');
  if (el) el.remove();
}

function hideEmpty() {
  const el = document.getElementById('emptyState');
  if (el) el.style.display = 'none';
}

function showEmpty() {
  const el = document.getElementById('emptyState');
  if (el) el.style.display = '';
}

function escapeHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// --- TTS (OpenAI server-side, played via AudioContext for iOS compat) ---
let ttsAudioPending = false;
let ttsAudioCtx = null;
let ttsSource = null;

// Create/resume AudioContext on user gesture (iOS requirement)
function ensureTtsContext() {
  if (!ttsAudioCtx) {
    ttsAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (ttsAudioCtx.state === 'suspended') {
    ttsAudioCtx.resume();
  }
  return ttsAudioCtx;
}

async function playTtsAudio(mp3Blob) {
  try {
    const ctx = ensureTtsContext();
    // Stop previous playback
    if (ttsSource) {
      try { ttsSource.stop(); } catch(e) {}
    }
    const arrayBuf = await mp3Blob.arrayBuffer();
    const audioBuf = await ctx.decodeAudioData(arrayBuf);
    ttsSource = ctx.createBufferSource();
    ttsSource.buffer = audioBuf;
    ttsSource.connect(ctx.destination);
    speaking = true;
    ttsSource.onended = () => { speaking = false; ttsSource = null; };
    ttsSource.start(0);
    console.log('TTS playing via AudioContext');
  } catch(e) {
    speaking = false;
    console.error('TTS playback error:', e);
  }
}

// --- Audio Capture ---
async function initAudio() {
  audioCtx = new AudioContext({ sampleRate: SAMPLE_RATE });
  mediaStream = await navigator.mediaDevices.getUserMedia({
    audio: { sampleRate: SAMPLE_RATE, channelCount: 1, echoCancellation: true, noiseSuppression: true }
  });
  const source = audioCtx.createMediaStreamSource(mediaStream);

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 256;
  source.connect(analyser);

  const processor = audioCtx.createScriptProcessor(4096, 1, 1);
  source.connect(processor);
  processor.connect(audioCtx.destination);
  processor.onaudioprocess = (e) => {
    if (recording) {
      audioChunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
    }
  };

  drawVisualizer();
}

function drawVisualizer() {
  const canvas = document.getElementById('visualizer');
  const ctx = canvas.getContext('2d');
  canvas.width = canvas.offsetWidth * 2;
  canvas.height = canvas.offsetHeight * 2;

  function draw() {
    animFrame = requestAnimationFrame(draw);
    if (!analyser) return;

    const bufLen = analyser.frequencyBinCount;
    const data = new Uint8Array(bufLen);
    analyser.getByteFrequencyData(data);

    ctx.fillStyle = '#111118';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw as smooth bars
    const barW = Math.max(2, (canvas.width / bufLen) * 1.8);
    const gap = 1;
    let x = (canvas.width - (barW + gap) * bufLen) / 2;
    for (let i = 0; i < bufLen; i++) {
      const v = data[i] / 255;
      const h = v * canvas.height * 0.9;
      const r = recording ? 239 : 129;
      const g = recording ? 68 : 140;
      const b = recording ? 68 : 248;
      const a = 0.15 + v * 0.85;
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
      ctx.beginPath();
      ctx.roundRect(x, canvas.height - h, barW, h, [barW/2, barW/2, 0, 0]);
      ctx.fill();
      x += barW + gap;
    }
  }
  draw();
}

// --- Recording Controls ---
function startRecording() {
  if (!audioCtx) return;
  // Ensure TTS AudioContext is unlocked during this user gesture
  ensureTtsContext();
  // Stop any ongoing speech
  if (speaking && ttsSource) { try { ttsSource.stop(); } catch(e) {} speaking = false; }
  audioChunks = [];
  recording = true;
  document.getElementById('micBtn').classList.add('recording');
  document.getElementById('micHint').textContent = 'listening...';
}

function stopRecording() {
  if (!recording) return;
  recording = false;
  document.getElementById('micBtn').classList.remove('recording');
  document.getElementById('micHint').textContent = 'processing...';

  const totalLen = audioChunks.reduce((s, c) => s + c.length, 0);
  const merged = new Float32Array(totalLen);
  let offset = 0;
  for (const chunk of audioChunks) {
    merged.set(chunk, offset);
    offset += chunk.length;
  }

  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(merged.buffer);
  }

  setTimeout(() => {
    const hint = document.getElementById('micHint');
    if (hint.textContent === 'processing...') hint.textContent = 'space / hold';
  }, 8000);
}

// --- Event Listeners ---
const btn = document.getElementById('micBtn');

btn.addEventListener('mousedown', async (e) => {
  e.preventDefault();
  if (!audioCtx) await initAudio();
  startRecording();
});
btn.addEventListener('mouseup', stopRecording);
btn.addEventListener('mouseleave', () => { if (recording) stopRecording(); });

btn.addEventListener('touchstart', async (e) => {
  e.preventDefault();
  if (!audioCtx) await initAudio();
  startRecording();
});
btn.addEventListener('touchend', (e) => { e.preventDefault(); stopRecording(); });

document.addEventListener('keydown', async (e) => {
  if (e.code === 'Space' && !e.repeat && !recording && e.target === document.body) {
    e.preventDefault();
    if (!audioCtx) await initAudio();
    startRecording();
  }
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'Space' && recording) {
    e.preventDefault();
    stopRecording();
  }
});

document.getElementById('clearBtn').addEventListener('click', () => {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'clear_history' }));
  }
});

connect();
</script>
</body>
</html>
